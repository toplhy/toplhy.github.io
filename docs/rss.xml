<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Toplhyi</title><link>https://toplhy.github.io</link><description>Toplhyi的烂摊子</description><copyright>Toplhyi</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/29943772?u=0084e717806403fb39c9a97ca92b10c88e380c3d&amp;v=4</url><title>avatar</title><link>https://toplhy.github.io</link></image><lastBuildDate>Mon, 01 Jul 2024 10:44:55 +0000</lastBuildDate><managingEditor>Toplhyi</managingEditor><ttl>60</ttl><webMaster>Toplhyi</webMaster><item><title>【JVM】24.可能出现的故障</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9124.-ke-neng-chu-xian-de-gu-zhang.html</link><description>## 可能出现的故障&#13;
+ 集群间同步导致内存溢出&#13;
&#13;
+ 堆外内存导致溢出错误&#13;
&#13;
  除了Java堆和永久代之外，下面这些区域还会闸弄较多的内存：&#13;
&#13;
  + Direct Memory：可通过-XX:MaxDirectMemorySize调整大小，内存不足时抛出OutOfMemoryError或者OutOfMemoryError：Direct buffer memory&#13;
&#13;
    垃圾收集进行时，虚拟机虽然会对Direct Memory进行回收，但是Direct Memory却不能像新生代、老年代那样，发现空间不足就通知收集器进行垃圾回收，它只能等待老年代满了后Full GC，然后顺便帮它清理掉内存中的废弃对象&#13;
&#13;
  + 线程堆栈：可通过-Xss调整大小，内存不足时抛出StackOverflowError或者OutOfMemoryError：unable  to create new native thread&#13;
&#13;
  + Socket缓存区：每个Socket连接都Receive和Send两个缓存区，分别占37KB和25KB内存，连接多的话这块内存占用也比较客观。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9124.-ke-neng-chu-xian-de-gu-zhang.html</guid><pubDate>Mon, 01 Jul 2024 10:44:34 +0000</pubDate></item><item><title>【JVM】23.高性能硬件上的程序部署策略</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9123.-gao-xing-neng-ying-jian-shang-de-cheng-xu-bu-shu-ce-lve.html</link><description>## 高性能硬件上的程序部署策略&#13;
&#13;
在高性能硬件上部署程序，目前有两种方式：&#13;
&#13;
+ 通过64位JDK来使用大内存&#13;
&#13;
  可以给虚拟机分配超大堆的前提是有把握把应用程序的Full GC频率控制得足够低，控制Full GC频率的关键是看应用中的绝大多数对象能否符合朝生夕死的原则，即大多数对象的生存时间不应太长，尤其是不能有成批量的、长时间生存的大对象产生，这样才能保障老年代空间的稳定。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9123.-gao-xing-neng-ying-jian-shang-de-cheng-xu-bu-shu-ce-lve.html</guid><pubDate>Mon, 01 Jul 2024 10:43:59 +0000</pubDate></item><item><title>【JVM】22.JDK可视化工具-VisualVM</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9122.JDK-ke-shi-hua-gong-ju--VisualVM.html</link><description>## JDK可视化工具-VisualVM&#13;
&#13;
VisualVM是随JDK发布的功能最强大的运行监视和故障处理程序。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9122.JDK-ke-shi-hua-gong-ju--VisualVM.html</guid><pubDate>Mon, 01 Jul 2024 10:43:26 +0000</pubDate></item><item><title>【JVM】21.JDK可视化工具-JConsole</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9121.JDK-ke-shi-hua-gong-ju--JConsole.html</link><description>## JDK可视化工具-JConsole&#13;
&#13;
JConsole是一种基于JMX的可视化监测、管理工具。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9121.JDK-ke-shi-hua-gong-ju--JConsole.html</guid><pubDate>Mon, 01 Jul 2024 10:42:51 +0000</pubDate></item><item><title>【JVM】20.JDK命令行工具-jstack</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9120.JDK-ming-ling-xing-gong-ju--jstack.html</link><description>## JDK命令行工具-jstack&#13;
&#13;
jstack命令用来生成虚拟机当前时刻的线程快照。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9120.JDK-ming-ling-xing-gong-ju--jstack.html</guid><pubDate>Mon, 01 Jul 2024 10:42:12 +0000</pubDate></item><item><title>【JVM】17.JDK命令行工具-jinfo</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9117.JDK-ming-ling-xing-gong-ju--jinfo.html</link><description>## JDK命令行工具-jinfo&#13;
&#13;
jinfo的作用是实时的查看和调整虚拟机各项参数。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9117.JDK-ming-ling-xing-gong-ju--jinfo.html</guid><pubDate>Mon, 01 Jul 2024 10:40:39 +0000</pubDate></item><item><title>【JVM】16.JDK命令行工具-jstat</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9116.JDK-ming-ling-xing-gong-ju--jstat.html</link><description>##  JDK命令行工具-jstat&#13;
&#13;
jstat：虚拟机统计信息监视工具&#13;
&#13;
jstat用于见识虚拟机各种运行状态信息的命令行工具。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9116.JDK-ming-ling-xing-gong-ju--jstat.html</guid><pubDate>Mon, 01 Jul 2024 10:40:03 +0000</pubDate></item><item><title>【JVM】15.JDK命令行工具-jps</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9115.JDK-ming-ling-xing-gong-ju--jps.html</link><description>## JDK命令行工具-jps&#13;
&#13;
jps：虚拟机进程状况工具&#13;
&#13;
jps可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Class，main函数所在的类）名称以及这些进程的本地虚拟机唯一ID（Local Virtual Machine Identifier，LVMID）。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9115.JDK-ming-ling-xing-gong-ju--jps.html</guid><pubDate>Mon, 01 Jul 2024 10:39:32 +0000</pubDate></item><item><title>【JVM】14.内存分配与回收策略</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9114.-nei-cun-fen-pei-yu-hui-shou-ce-lve.html</link><description>## 内存分配与回收策略&#13;
&#13;
+ 对象优先在Eden分配&#13;
&#13;
  大多数情况下，对象在新生代Eden区中分配。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9114.-nei-cun-fen-pei-yu-hui-shou-ce-lve.html</guid><pubDate>Mon, 01 Jul 2024 10:39:01 +0000</pubDate></item><item><title>【JVM】13.GC日志和垃圾收集器参数总结</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9113.GC-ri-zhi-he-la-ji-shou-ji-qi-can-shu-zong-jie.html</link><description>## GC日志和垃圾收集器参数总结&#13;
&#13;
+ GC日志&#13;
&#13;
  例：33.125:  [GC  [DefNew:  3324/k-&gt;152K(3712K),  0.0025925 secs]  3324K-&gt;152K(11904K), 0.0031680 secs]&#13;
&#13;
  例：100.667:  [Full GC  [Tenured:  0K-&gt;210K(10240K), 0.0149142  secs]  4603K-&gt;210K(19456K),  [Perm:  2999K-&gt;2999K(21248K), 0.0150007  secs]]  &#13;
&#13;
  + 33.125、 100.667：表示GC发生的时间，这数字指的是从虚拟机启动以来经过的秒数。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9113.GC-ri-zhi-he-la-ji-shou-ji-qi-can-shu-zong-jie.html</guid><pubDate>Mon, 01 Jul 2024 10:38:15 +0000</pubDate></item><item><title>【JVM】12.垃圾收集器3-G1收集器</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9112.-la-ji-shou-ji-qi-3-G1-shou-ji-qi.html</link><description>## 垃圾收集器3-G1收集器&#13;
&#13;
G1收集器是当今收集器技术发展最前沿的成果之一，与其他收集器相比，G1收集器具备一下特点：&#13;
&#13;
+ 并行与并发：其他部分收集器原本需要停顿Java线程执行的GC动作，G1收集器任然可以通过并发的方式让Java线程继续运行。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9112.-la-ji-shou-ji-qi-3-G1-shou-ji-qi.html</guid><pubDate>Mon, 01 Jul 2024 10:33:55 +0000</pubDate></item><item><title>【JVM】11.垃圾收集器2-CMS收集器</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9111.-la-ji-shou-ji-qi-2-CMS-shou-ji-qi.html</link><description>## 垃圾收集器2-CMS收集器&#13;
&#13;
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9111.-la-ji-shou-ji-qi-2-CMS-shou-ji-qi.html</guid><pubDate>Mon, 01 Jul 2024 10:31:45 +0000</pubDate></item><item><title>【JVM】10.垃圾收集器1</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9110.-la-ji-shou-ji-qi-1.html</link><description>## 垃圾收集器1&#13;
&#13;
### Serial收集器&#13;
&#13;
   Serial收集器是最基本、发展历史最悠久的收集器。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9110.-la-ji-shou-ji-qi-1.html</guid><pubDate>Mon, 01 Jul 2024 08:15:45 +0000</pubDate></item><item><title>【JVM】9.枚举根节点、安全点、安全区域</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%919.-mei-ju-gen-jie-dian-%E3%80%81-an-quan-dian-%E3%80%81-an-quan-qu-yu.html</link><description>## 枚举根节点、安全点、安全区域&#13;
&#13;
### 1. 枚举根节点&#13;
&#13;
   可作为GC Roots的节点主要在全局性引用（常量、类静态属性）和执行上下文（栈帧中的本地变量表）。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%919.-mei-ju-gen-jie-dian-%E3%80%81-an-quan-dian-%E3%80%81-an-quan-qu-yu.html</guid><pubDate>Mon, 01 Jul 2024 08:15:13 +0000</pubDate></item><item><title>【JVM】8.垃圾收集算法</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%918.-la-ji-shou-ji-suan-fa.html</link><description>## 垃圾收集算法&#13;
&#13;
### 1. 标记-清除算法&#13;
&#13;
   分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，在标记完成后统一回收所有被标记的对象。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%918.-la-ji-shou-ji-suan-fa.html</guid><pubDate>Mon, 01 Jul 2024 08:14:41 +0000</pubDate></item><item><title>【JVM】7.对象存活判定</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%917.-dui-xiang-cun-huo-pan-ding.html</link><description>## 对象存活判定&#13;
&#13;
![jvm_7](/images/jvm/jvm_7.png)&#13;
&#13;
+ 对象没有覆盖finalize()方法或者finalize()方法已被虚拟机调用过，虚拟机将认为这两种情况为“没有必要执行”。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%917.-dui-xiang-cun-huo-pan-ding.html</guid><pubDate>Mon, 01 Jul 2024 08:14:10 +0000</pubDate></item><item><title>【JVM】6.对象引用类型</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%916.-dui-xiang-yin-yong-lei-xing.html</link><description>## 对象引用类型（Reference）&#13;
&#13;
Java将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%916.-dui-xiang-yin-yong-lei-xing.html</guid><pubDate>Mon, 01 Jul 2024 08:13:30 +0000</pubDate></item><item><title>【JVM】5.检测对象是否已经被引用</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%915.-jian-ce-dui-xiang-shi-fou-yi-jing-bei-yin-yong.html</link><description>## 检测对象是否已经被引用&#13;
&#13;
在进行垃圾回收之前，首先要确定对象是否已经引用。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%915.-jian-ce-dui-xiang-shi-fou-yi-jing-bei-yin-yong.html</guid><pubDate>Mon, 01 Jul 2024 08:08:11 +0000</pubDate></item><item><title>【JVM】4.对象的访问定位</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%914.-dui-xiang-de-fang-wen-ding-wei.html</link><description>## 对象的访问定位&#13;
&#13;
使用对象时Java程序通过栈上的reference数据来操作堆上的对象实例。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%914.-dui-xiang-de-fang-wen-ding-wei.html</guid><pubDate>Mon, 01 Jul 2024 08:07:39 +0000</pubDate></item><item><title>【JVM】3.对象的内存布局</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%913.-dui-xiang-de-nei-cun-bu-ju.html</link><description>## 对象的内存布局&#13;
&#13;
对象在内存中的布局分为3块区域：对象头、实例数据、对齐填充。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%913.-dui-xiang-de-nei-cun-bu-ju.html</guid><pubDate>Mon, 01 Jul 2024 08:05:52 +0000</pubDate></item><item><title>【JVM】 2.对象的创建过程</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%91%202.-dui-xiang-de-chuang-jian-guo-cheng.html</link><description>## 对象的创建过程&#13;
&#13;
![jvm_2](/images/jvm/jvm_2.png)&#13;
&#13;
&#13;
+ 为对象分配内存：指针碰撞、空闲列表。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%91%202.-dui-xiang-de-chuang-jian-guo-cheng.html</guid><pubDate>Mon, 01 Jul 2024 08:05:22 +0000</pubDate></item><item><title>【JVM】1.Java运行时内存区域划分</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%911.Java-yun-xing-shi-nei-cun-qu-yu-hua-fen.html</link><description>## Java运行时内存区域划分&#13;
&#13;
### 1.程序计数器：&#13;
&#13;
为线程私有，存储的是当前线程所执行程序的内存地址。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%911.Java-yun-xing-shi-nei-cun-qu-yu-hua-fen.html</guid><pubDate>Mon, 01 Jul 2024 08:04:42 +0000</pubDate></item><item><title>Grails自定义权限标签</title><link>https://toplhy.github.io/post/Grails-zi-ding-yi-quan-xian-biao-qian.html</link><description>grails项目中使用了spring security 插件实现身份认证。</description><guid isPermaLink="true">https://toplhy.github.io/post/Grails-zi-ding-yi-quan-xian-biao-qian.html</guid><pubDate>Mon, 01 Jul 2024 08:02:52 +0000</pubDate></item><item><title>Grails2.X开发调用WebService</title><link>https://toplhy.github.io/post/Grails2.X-kai-fa-diao-yong-WebService.html</link><description>## 开发webservice接口&#13;
&#13;
### 1. 新建grails1/2工程项目&#13;
&#13;
### 2. 在BuildConfig.groovy文件的plugins闭包中加入cxf服务端插件：&#13;
&#13;
```&#13;
compile 'org.grails.plugins:cxf:2.1.1'&#13;
```&#13;
&#13;
### 3. 在Config.groovy文件中配置cxf&#13;
![1](https://github.com/toplhy/toplhy.github.io/blob/main/images/grails/grails_1.png?raw=true)&#13;
&#13;
### 4. 在grails-app/services目录下创建一个TestService类&#13;
&#13;
### 5. 启动项目&#13;
输入http://localhost:8080/cxfProject/services 可以看到我们开发的接口，点击链接就是生成的WSDL文件。</description><guid isPermaLink="true">https://toplhy.github.io/post/Grails2.X-kai-fa-diao-yong-WebService.html</guid><pubDate>Mon, 01 Jul 2024 07:34:10 +0000</pubDate></item></channel></rss>