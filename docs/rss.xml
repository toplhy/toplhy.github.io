<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>Toplhyi</title><link>https://toplhy.github.io</link><description>Toplhyi的烂摊子</description><copyright>Toplhyi</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/29943772?u=0084e717806403fb39c9a97ca92b10c88e380c3d&amp;v=4</url><title>avatar</title><link>https://toplhy.github.io</link></image><lastBuildDate>Mon, 01 Jul 2024 10:38:35 +0000</lastBuildDate><managingEditor>Toplhyi</managingEditor><ttl>60</ttl><webMaster>Toplhyi</webMaster><item><title>【JVM】13.GC日志和垃圾收集器参数总结</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9113.GC-ri-zhi-he-la-ji-shou-ji-qi-can-shu-zong-jie.html</link><description>## GC日志和垃圾收集器参数总结&#13;
&#13;
+ GC日志&#13;
&#13;
  例：33.125:  [GC  [DefNew:  3324/k-&gt;152K(3712K),  0.0025925 secs]  3324K-&gt;152K(11904K), 0.0031680 secs]&#13;
&#13;
  例：100.667:  [Full GC  [Tenured:  0K-&gt;210K(10240K), 0.0149142  secs]  4603K-&gt;210K(19456K),  [Perm:  2999K-&gt;2999K(21248K), 0.0150007  secs]]  &#13;
&#13;
  + 33.125、 100.667：表示GC发生的时间，这数字指的是从虚拟机启动以来经过的秒数。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9113.GC-ri-zhi-he-la-ji-shou-ji-qi-can-shu-zong-jie.html</guid><pubDate>Mon, 01 Jul 2024 10:38:15 +0000</pubDate></item><item><title>【JVM】12.垃圾收集器3-G1收集器</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9112.-la-ji-shou-ji-qi-3-G1-shou-ji-qi.html</link><description>## 垃圾收集器3-G1收集器&#13;
&#13;
G1收集器是当今收集器技术发展最前沿的成果之一，与其他收集器相比，G1收集器具备一下特点：&#13;
&#13;
+ 并行与并发：其他部分收集器原本需要停顿Java线程执行的GC动作，G1收集器任然可以通过并发的方式让Java线程继续运行。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9112.-la-ji-shou-ji-qi-3-G1-shou-ji-qi.html</guid><pubDate>Mon, 01 Jul 2024 10:33:55 +0000</pubDate></item><item><title>【JVM】11.垃圾收集器2-CMS收集器</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9111.-la-ji-shou-ji-qi-2-CMS-shou-ji-qi.html</link><description>## 垃圾收集器2-CMS收集器&#13;
&#13;
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9111.-la-ji-shou-ji-qi-2-CMS-shou-ji-qi.html</guid><pubDate>Mon, 01 Jul 2024 10:31:45 +0000</pubDate></item><item><title>【JVM】10.垃圾收集器1</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9110.-la-ji-shou-ji-qi-1.html</link><description>## 垃圾收集器1&#13;
&#13;
### Serial收集器&#13;
&#13;
   Serial收集器是最基本、发展历史最悠久的收集器。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%9110.-la-ji-shou-ji-qi-1.html</guid><pubDate>Mon, 01 Jul 2024 08:15:45 +0000</pubDate></item><item><title>【JVM】9.枚举根节点、安全点、安全区域</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%919.-mei-ju-gen-jie-dian-%E3%80%81-an-quan-dian-%E3%80%81-an-quan-qu-yu.html</link><description>## 枚举根节点、安全点、安全区域&#13;
&#13;
### 1. 枚举根节点&#13;
&#13;
   可作为GC Roots的节点主要在全局性引用（常量、类静态属性）和执行上下文（栈帧中的本地变量表）。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%919.-mei-ju-gen-jie-dian-%E3%80%81-an-quan-dian-%E3%80%81-an-quan-qu-yu.html</guid><pubDate>Mon, 01 Jul 2024 08:15:13 +0000</pubDate></item><item><title>【JVM】8.垃圾收集算法</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%918.-la-ji-shou-ji-suan-fa.html</link><description>## 垃圾收集算法&#13;
&#13;
### 1. 标记-清除算法&#13;
&#13;
   分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，在标记完成后统一回收所有被标记的对象。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%918.-la-ji-shou-ji-suan-fa.html</guid><pubDate>Mon, 01 Jul 2024 08:14:41 +0000</pubDate></item><item><title>【JVM】7.对象存活判定</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%917.-dui-xiang-cun-huo-pan-ding.html</link><description>## 对象存活判定&#13;
&#13;
![jvm_7](/images/jvm/jvm_7.png)&#13;
&#13;
+ 对象没有覆盖finalize()方法或者finalize()方法已被虚拟机调用过，虚拟机将认为这两种情况为“没有必要执行”。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%917.-dui-xiang-cun-huo-pan-ding.html</guid><pubDate>Mon, 01 Jul 2024 08:14:10 +0000</pubDate></item><item><title>【JVM】6.对象引用类型</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%916.-dui-xiang-yin-yong-lei-xing.html</link><description>## 对象引用类型（Reference）&#13;
&#13;
Java将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%916.-dui-xiang-yin-yong-lei-xing.html</guid><pubDate>Mon, 01 Jul 2024 08:13:30 +0000</pubDate></item><item><title>【JVM】5.检测对象是否已经被引用</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%915.-jian-ce-dui-xiang-shi-fou-yi-jing-bei-yin-yong.html</link><description>## 检测对象是否已经被引用&#13;
&#13;
在进行垃圾回收之前，首先要确定对象是否已经引用。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%915.-jian-ce-dui-xiang-shi-fou-yi-jing-bei-yin-yong.html</guid><pubDate>Mon, 01 Jul 2024 08:08:11 +0000</pubDate></item><item><title>【JVM】4.对象的访问定位</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%914.-dui-xiang-de-fang-wen-ding-wei.html</link><description>## 对象的访问定位&#13;
&#13;
使用对象时Java程序通过栈上的reference数据来操作堆上的对象实例。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%914.-dui-xiang-de-fang-wen-ding-wei.html</guid><pubDate>Mon, 01 Jul 2024 08:07:39 +0000</pubDate></item><item><title>【JVM】3.对象的内存布局</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%913.-dui-xiang-de-nei-cun-bu-ju.html</link><description>## 对象的内存布局&#13;
&#13;
对象在内存中的布局分为3块区域：对象头、实例数据、对齐填充。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%913.-dui-xiang-de-nei-cun-bu-ju.html</guid><pubDate>Mon, 01 Jul 2024 08:05:52 +0000</pubDate></item><item><title>【JVM】 2.对象的创建过程</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%91%202.-dui-xiang-de-chuang-jian-guo-cheng.html</link><description>## 对象的创建过程&#13;
&#13;
![jvm_2](/images/jvm/jvm_2.png)&#13;
&#13;
&#13;
+ 为对象分配内存：指针碰撞、空闲列表。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%91%202.-dui-xiang-de-chuang-jian-guo-cheng.html</guid><pubDate>Mon, 01 Jul 2024 08:05:22 +0000</pubDate></item><item><title>【JVM】1.Java运行时内存区域划分</title><link>https://toplhy.github.io/post/%E3%80%90JVM%E3%80%911.Java-yun-xing-shi-nei-cun-qu-yu-hua-fen.html</link><description>## Java运行时内存区域划分&#13;
&#13;
### 1.程序计数器：&#13;
&#13;
为线程私有，存储的是当前线程所执行程序的内存地址。</description><guid isPermaLink="true">https://toplhy.github.io/post/%E3%80%90JVM%E3%80%911.Java-yun-xing-shi-nei-cun-qu-yu-hua-fen.html</guid><pubDate>Mon, 01 Jul 2024 08:04:42 +0000</pubDate></item><item><title>Grails自定义权限标签</title><link>https://toplhy.github.io/post/Grails-zi-ding-yi-quan-xian-biao-qian.html</link><description>grails项目中使用了spring security 插件实现身份认证。</description><guid isPermaLink="true">https://toplhy.github.io/post/Grails-zi-ding-yi-quan-xian-biao-qian.html</guid><pubDate>Mon, 01 Jul 2024 08:02:52 +0000</pubDate></item><item><title>Grails2.X开发调用WebService</title><link>https://toplhy.github.io/post/Grails2.X-kai-fa-diao-yong-WebService.html</link><description>## 开发webservice接口&#13;
&#13;
### 1. 新建grails1/2工程项目&#13;
&#13;
### 2. 在BuildConfig.groovy文件的plugins闭包中加入cxf服务端插件：&#13;
&#13;
```&#13;
compile 'org.grails.plugins:cxf:2.1.1'&#13;
```&#13;
&#13;
### 3. 在Config.groovy文件中配置cxf&#13;
![1](https://github.com/toplhy/toplhy.github.io/blob/main/images/grails/grails_1.png?raw=true)&#13;
&#13;
### 4. 在grails-app/services目录下创建一个TestService类&#13;
&#13;
### 5. 启动项目&#13;
输入http://localhost:8080/cxfProject/services 可以看到我们开发的接口，点击链接就是生成的WSDL文件。</description><guid isPermaLink="true">https://toplhy.github.io/post/Grails2.X-kai-fa-diao-yong-WebService.html</guid><pubDate>Mon, 01 Jul 2024 07:34:10 +0000</pubDate></item></channel></rss>