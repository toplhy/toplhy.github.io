## 内存分配与回收策略

+ 对象优先在Eden分配

  大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

  + Minor GC：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也比较快。
  + Major GC/Full GC：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对）。Major GC的速度一般会比Minor GC慢10倍以上。

+ 大对象直接进入老年代

  大对象是指需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组。经常出现大对象容易导致内存还有不少空间就提前出发垃圾收集以获取足够的连续空间来安置它们。

  虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的复制。

+ 长期存活的对象将进入老年代

  虚拟机给每个对象定义了一个对象年龄计数器。对象没在Survivor区中度过一次Minor GC，年龄就增加1岁，当它的年龄增加到15岁（默认），对象将晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。

+ 动态对象年龄判断

  虚拟机并不是永远的要求对象必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的子总和大于Sucvivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

+ 空间分配担保

  在发生Minor GC前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么Minor GC确保是安全的。如果不成立，虚拟机继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，则改为进行一次Full GC。

